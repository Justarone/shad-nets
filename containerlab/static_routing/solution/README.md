# lab01

## скрипты

скрипты находятся в папке [./scripts](./scripts)

[ролик пример](./sample.mp4)

обоим скриптам можно передать 2 параметра:
1. `-c` - конфиг (по дефолту - ищет в папке исполнения `config.json`, там есть)
2. `-t` - файл с топологией, на основе которого в том числе генерятся адреса, выполняются команды в контейнерах, настраивающие интерфейсы и машрутизацию

пример команды запуска: `cd scripts && python3 generator.py -t ../clab.yml`

из настроек:
0. общая - `docker_command` - какой командой запускать докер (у меня настроена `docker` группа локально, поэтому я запускаю без `sudo`, если нужен `sudo`, то надо задать этот параметр в значение `sudo docker`, по умолчанию просто `docker`)
1. `generator.py`
    * `execute_commands` - выполнять ли команды или просто вывести отображение `node -> [vtysh_commands]`
    * `execute_prepare` - почему-то у меня vtysh не выполняет множество команд через `-c c1 -c c2`, если нет файла конфигурации, поэтому я его создаю (по дефолту true, но можно отключить, делает `touch /etc/frr/vtysh.conf`)
2. `checker.py`
    * `check_all` - если выставлено, то выполнит все заданные команды для всех нод и до всех ip (по умолчанию `true`, удобно из команд задать только пинг и проверить связность везде сразу)
    * `check_nodes` - если не `check_all`, то проверит только эти ноды (в формате `routerX`/`PCX`)
    * `check_ips` - если не `check_all`, то проверит communication команды только до этих ip
    * `check_node_commands` - по умолчанию все `['sh run', 'sh int brief', 'sh ip route']` - список команд для проверки на нодах из `check_nodes` (или всех, если `check_all`)
    * `check_communication_commands` - по умолчанию все `['ping', 'traceroute']` - список команд, которые применяются со всех нод из `check_nodes` и всех ip из `check_ips` (или всех возможных пар node->ip, если `check_all`)
    * `show_docker_ps` - выводит `docker ps`, по умолчанию `false`

## нетривиальные моменты

### добавление всех ip машрутизаторов

напрямую подключенные ip маршрутизаторов разрешаются автоматически, но если попробовать с router1 выполнить команду `ping 192.168.3.2`, она не выполнится для конфигурации из лабы - для этих адресов (фактически ip с другого интерфейса router2) надо явно задать правило, которое ведет в eth1 router1, при этом traceroute выводит:
```
router1# traceroute 192.168.3.2
traceroute to 192.168.3.2 (192.168.3.2), 30 hops max, 46 byte packets
 1  192.168.3.2 (192.168.3.2)  0.013 ms  0.035 ms  0.007 ms
```
что является правдой - мы напрямую соединены с router2, которому принадлежит этот ip

### настройка PCX

если задать для PC routes:
```
ip route 192.168.22.0/24 192.168.11.1 eth1
ip route 192.168.33.0/24 192.168.11.1 eth1
```

как в инструкции, то он не может отвечать на пинги router (не прямо подключенного, а двух других), поэтому я задал `ip route 192.168.0.0/16 192.168.11.1 eth1` - более "широкое" правило - альтернативно можно было задать явно все ip, с которых приходят пинги от маршрутизаторов или все сети маршрутизаторов.

### отключение ethY интерфейса где-либо

пусть мы отключаем eth1 интерфейс на router1. тогда у меня ожидаемо перестают проходить пинги между PC1 и router2/PC2. это можно исправить не включая интерфейс, если:
1. добавить `ip route` отдельной записью в router1 - для всего, что шло в eth1, дописать аналогичную запись с eth2 - когда все хорошо, выбирается первая запись, а когда eth1 отключается, пакеты отсылаются в eth2. (\*)
2. добавить в `ip route` отдельными записями в router2 аналогично - дописать все сети с интерфейсом eth1 в eth2. (\*)

(\*) - примечание: в текущей топологии так сделать можно, потому что при прихождении в router3 данных, которые должны идти в router2, он отправит их в router2, аналогично для router1. но если бы топология была более сложная (например, кольцо 4 маршрутизаторов), то было бы сложнее - если router4 шлет данные в router2 через router1, то когда router1 будет попытаться послать данные в router2 через router4 (потому что выключается интерфейс между router1 и router2), router4 в конфигурации по умолчанию будет слать эти пакеты обратно (даже если мы зададим еще один путь для router4, то он не будет его использовать, потому что у него все хорошо в интерфейсе с router1 и старая запись будет *selected route*).
