# lab02

## по заданию

при разрыве между R1-R2 таблицы перестраиваются и путь от R1 в сеть 192.168.22.0 начинает лежать через eth2 - эту информацию получает router3 от router2 в виде LSP, затем router1 от router3 и перестраивает свою rib.

```
PC1# traceroute 192.168.22.4
traceroute to 192.168.22.4 (192.168.22.4), 30 hops max, 46 byte packets
 1  192.168.11.1 (192.168.11.1)  0.010 ms  0.009 ms  0.004 ms
 2  192.168.2.3 (192.168.2.3)  0.004 ms  0.009 ms  0.005 ms
 3  192.168.3.2 (192.168.3.2)  0.004 ms  0.009 ms  0.004 ms
 4  192.168.22.4 (192.168.22.4)  0.003 ms  0.007 ms  0.004 ms
```

```
router1: sh ip route
...
I>* 192.168.22.0/24 [115/30] via 192.168.2.3, eth2, weight 1, 00:00:03
...
```

как только линк возвращается, находится более оптимальный путь, который был изначально:

```
PC1# traceroute 192.168.22.4
traceroute to 192.168.22.4 (192.168.22.4), 30 hops max, 46 byte packets
 1  192.168.11.1 (192.168.11.1)  0.004 ms  0.002 ms  0.001 ms
 2  192.168.1.2 (192.168.1.2)  0.001 ms  0.002 ms  0.001 ms
 3  192.168.22.4 (192.168.22.4)  0.002 ms  0.003 ms  0.000 ms
```

```
router1# sh ip route
...
I>* 192.168.22.0/24 [115/20] via 192.168.1.2, eth1, weight 1, 00:01:10
...
```

при этом при отключении линка router2 не пропадает 

## скрипты

по аналогии с лабораторной №1, скрипты находятся в папке [./scripts](./scripts)

обоим скриптам можно передать 2 параметра:
1. `-c` - конфиг (по дефолту - ищет в папке исполнения `config.json`, там есть)
2. `-t` - файл с топологией, на основе которого в том числе генерятся адреса, выполняются команды в контейнерах, настраивающие интерфейсы и машрутизацию

пример команды запуска: `cd scripts && python3 generator.py -t ../clab.yml`

из настроек:
0. общая - `docker_command` - какой командой запускать докер (у меня настроена `docker` группа локально, поэтому я запускаю без `sudo`, если нужен `sudo`, то надо задать этот параметр в значение `sudo docker`, по умолчанию просто `docker`)
1. `generator.py`
    * `execute_commands` - выполнять ли команды или просто вывести отображение `node -> [vtysh_commands]`
    * `execute_prepare` - почему-то у меня vtysh не выполняет множество команд через `-c c1 -c c2`, если нет файла конфигурации, поэтому я его создаю (по дефолту true, но можно отключить, делает `touch /etc/frr/vtysh.conf`)
2. `checker.py`
    * `check_all` - если выставлено, то выполнит все заданные команды для всех нод и до всех ip (по умолчанию `true`, удобно из команд задать только пинг и проверить связность везде сразу)
    * `check_nodes` - если не `check_all`, то проверит только эти ноды (в формате `routerX`/`PCX`)
    * `check_ips` - если не `check_all`, то проверит communication команды только до этих ip
    * `check_node_commands` - по умолчанию все `['sh run', 'sh int brief', 'sh ip route', 'sh isis database', 'sh isis database detail', 'sh isis interface', 'sh isis interface detail', 'sh isis neighbor detail']` - список команд для проверки на нодах из `check_nodes` (или всех, если `check_all`)
    * `check_communication_commands` - по умолчанию все `['ping', 'traceroute']` - список команд, которые применяются со всех нод из `check_nodes` и всех ip из `check_ips` (или всех возможных пар `node->ip`, если `check_all`)
    * `show_docker_ps` - выводит `docker ps`, по умолчанию `false`

## нетривиальные моменты

### на построение маршрутов требуется время

после прогона скриптов по настройке isis на интерфейсах требуется какое-то время (эмперически 25-35 секунд), пока isis построит пути графа и внесет информацию в rib. аналогичное время требуется, когда мы отключаем линк - все пути, которые лежали через этот линк, заработают лишь тогда, когда таблица перестроится.

примеры в видео:
1. [лаг при запуске](./start_lag.mp4)
2. [перестроение sh ip route при отключении link'a](./shutdown.mp4)

### не самый оптимальный путь

в 1 лабораторной работе при настройке статической маршрутизации можно было настроить путь от router1 до интерфейса router2 с ip=192.168.3.2 напрямую (и traceroute показывал 1 hop), в случае с isis путь проходит через router3. 

```
router1# traceroute 192.168.3.2
traceroute to 192.168.3.2 (192.168.3.2), 30 hops max, 46 byte packets
 1  192.168.2.3 (192.168.2.3)  0.011 ms  0.013 ms  0.003 ms
 2  192.168.3.2 (192.168.3.2)  0.004 ms  0.014 ms  0.003 ms

```
при этом в таблице машрутизации следующая запись:
```
I>* 192.168.3.0/24 [115/20] via 192.168.1.2, eth1, weight 1, 00:22:13
  *                         via 192.168.2.3, eth2, weight 1, 00:22:13
```
то есть вся сеть выделилась `192.168.3.0/24` в 1 запись, хотя оптимальнее было бы ходить в соседние маршрутизаторы по прямым путям.

при этом если отключить интерфейс eth2, дождаться перестроения rib, и дальше снова включить и дождаться, то по итогу останется путь через eth1:)

в моем понимании такое происходит, потому что router2 и router3 на своих интерфейсах имеют адрес в формате `192.168.3.X/24`, поэтому отдают одинаковую стоимость до подсети `192.168.3.0/24` и берется просто одно из этих значений - это можно увидеть в `sh isis database detail` у router1:

```
router2.00-00             115   0x00000003  0x68df    1103    0/0/0
  ...
  Extended IP Reachability: 192.168.3.0/24 (Metric: 10)
  ...

router3.00-00             134   0x00000002  0x81cb     711    0/0/0
  ...
  Extended IP Reachability: 192.168.3.0/24 (Metric: 10)
  ...
```

## дублирование записей

для напрямую подключенных интерфейсов есть 2 записи - C/I, зачем-то ISIS дублирует запись, но C имеет больший приоритет и является активной в rib.
